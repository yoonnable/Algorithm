package study.baekjoon.dp;

import java.util.Scanner;

public class P2133 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        P2133 m = new P2133();
        int n = sc.nextInt();
        System.out.println(m.solution(n));
    }
    public int solution(int n) {
        // n이 홀수일 땐 채울 수 없다.
        // n이 짝수일 때만 채울 수 있음.
        // n = 2, 3가지
        // n = 4, 3*3 + 2 = 11가지
        // ## n을 2,2로 나눠서 각각 n=2일때 채울 수 있는 경우의 수들을 곱한 것 => 3*3 = 9가지
        // ## n = 4일때만 채울 수 있는 방법 2가지 를 더한다.

        // n = 6, 11*3 + 3*2 + 2 = 41가지
        // ## n을 4,2로 나눴을 때 4까지 11가지 경우가 있고, 나머지 2에 3가지 경우가 있는 걸 곱한 것 => 11*3 = 33가지,
        // ## 위 경우에 포함되지 않는, 2,4로 나눠서 2부분은 3가지, 4부분에 4일 때만 채울 수 있는 방법 2가지를 곱한 것 => 3*2 = 6가지,
        // ## n = 6일때만 채울 수 있는 방법 2가지 를 더한다.

        // n = 8, 41*3 + 11*2 + 3*2 + 2
        // ## n을 6,2로 나눴을 때 6까지 41가지 경우가 있고, 나머지 2에 3가지 경우가 있는 걸 곱한 것 => 41*3
        // ## 위 경우에 포함되지 않는, 4,4로 나눴을 때, 앞쪽 4부분은 11가지, 뒷쪽 4부분엔 4일 때만 채울 수 있는 방법 2가지를 곱한 것 => 11*2
        // ## 위 경우에 포함되지 않는, 2,6로 나눴을 때, 2부분은 3가지, 6부분에 6일 때만 채울 수 있는 방법 2가지를 곱한 것 => 3*2
        // ## n = 8일때만 채울 수 있는 방법 2가지 를 더한다.
        // 식을 좀 더 쉽게 정리하면, 41*3 + 2(11 + 3) + 2

        // 즉,
        // 1. n-2의 경우의 수 * 3
        // 2. n-4(2씩 증가) ~ 2가 될 때까지의 경우의 수를 모두 더한 값에 * 2
        // 3. +2
        // 1~3을 모두 더한 값이 최종 답이 된다.

        if(n%2 != 0) return 0; // n이 홀수일 땐 채울 수 없다.

        int[] dp = new int[n + 1];
        if(n > 1) dp[2] = 3;
        for(int i = 4; i <= n; i = i+2) {
            int temp = i - 2;
            dp[i] = dp[temp] * 3;
            temp = temp - 2;
            int sub = 0;
            while(temp > 1) {
                sub = sub + dp[temp];
                temp = temp - 2;
            }
            dp[i] = dp[i] + 2 * sub + 2;
        }
        return dp[n];
    }
}
